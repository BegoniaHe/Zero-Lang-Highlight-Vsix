{
  "Function Definition": {
    "prefix": "fn",
    "body": [
      "fn ${1:name}(${2:params}) -> ${3:ReturnType} {",
      "\t$0",
      "}"
    ],
    "description": "Define a new function"
  },
  "Main Function": {
    "prefix": "main",
    "body": [
      "fn main() {",
      "\t$0",
      "}"
    ],
    "description": "Main entry point"
  },
  "Struct Definition": {
    "prefix": "struct",
    "body": [
      "struct ${1:Name} {",
      "\t${2:field}: ${3:Type},$0",
      "}"
    ],
    "description": "Define a new struct"
  },
  "Enum Definition": {
    "prefix": "enum",
    "body": [
      "enum ${1:Name} {",
      "\t${2:Variant},$0",
      "}"
    ],
    "description": "Define a new enum"
  },
  "Interface Definition": {
    "prefix": "interface",
    "body": [
      "interface ${1:Name} {",
      "\tfn ${2:method}(${3:params}) -> ${4:ReturnType};$0",
      "}"
    ],
    "description": "Define a new interface"
  },
  "Implementation Block": {
    "prefix": "impl",
    "body": [
      "impl ${1:Type} {",
      "\t$0",
      "}"
    ],
    "description": "Implementation block for a type"
  },
  "Implement Interface": {
    "prefix": "implfor",
    "body": [
      "impl ${1:Interface} for ${2:Type} {",
      "\t$0",
      "}"
    ],
    "description": "Implement an interface for a type"
  },
  "If Statement": {
    "prefix": "if",
    "body": [
      "if ${1:condition} {",
      "\t$0",
      "}"
    ],
    "description": "If statement"
  },
  "If-Else Statement": {
    "prefix": "ife",
    "body": [
      "if ${1:condition} {",
      "\t$2",
      "} else {",
      "\t$0",
      "}"
    ],
    "description": "If-else statement"
  },
  "If-Else If Statement": {
    "prefix": "ifei",
    "body": [
      "if ${1:condition} {",
      "\t$2",
      "} else if ${3:condition} {",
      "\t$0",
      "}"
    ],
    "description": "If-else if statement"
  },
  "Match Expression": {
    "prefix": "match",
    "body": [
      "match ${1:value} {",
      "\t${2:pattern} => ${3:result},$0",
      "}"
    ],
    "description": "Match expression"
  },
  "For Loop": {
    "prefix": "for",
    "body": [
      "for ${1:item} in ${2:iterator} {",
      "\t$0",
      "}"
    ],
    "description": "For loop"
  },
  "For Range Loop": {
    "prefix": "forr",
    "body": [
      "for ${1:i} in ${2:0}..${3:n} {",
      "\t$0",
      "}"
    ],
    "description": "For loop with range"
  },
  "While Loop": {
    "prefix": "while",
    "body": [
      "while ${1:condition} {",
      "\t$0",
      "}"
    ],
    "description": "While loop"
  },
  "Loop": {
    "prefix": "loop",
    "body": [
      "loop {",
      "\t$0",
      "}"
    ],
    "description": "Infinite loop"
  },
  "Variable Declaration": {
    "prefix": "var",
    "body": [
      "var ${1:name}: ${2:Type} = ${3:value};$0"
    ],
    "description": "Variable declaration with type"
  },
  "Mutable Variable": {
    "prefix": "mut",
    "body": [
      "mut ${1:name}: ${2:Type} = ${3:value};$0"
    ],
    "description": "Mutable variable declaration"
  },
  "Constant": {
    "prefix": "const",
    "body": [
      "const ${1:NAME}: ${2:Type} = ${3:value};$0"
    ],
    "description": "Constant declaration"
  },
  "Generic Function": {
    "prefix": "fng",
    "body": [
      "fn ${1:name}<${2:T}>(${3:param}: ${2:T}) -> ${4:ReturnType} {",
      "\t$0",
      "}"
    ],
    "description": "Generic function"
  },
  "Test Function": {
    "prefix": "test",
    "body": [
      "#[test]",
      "fn ${1:test_name}() {",
      "\t$0",
      "}"
    ],
    "description": "Test function"
  },
  "Lambda/Closure": {
    "prefix": "lambda",
    "body": [
      "|${1:params}| ${2:expr}$0"
    ],
    "description": "Lambda expression"
  },
  "Closure with Block": {
    "prefix": "closure",
    "body": [
      "|${1:params}| {",
      "\t$0",
      "}"
    ],
    "description": "Closure with block body"
  },
  "Print": {
    "prefix": "print",
    "body": [
      "print(\"${1:message}\");$0"
    ],
    "description": "Print statement"
  },
  "Println": {
    "prefix": "println",
    "body": [
      "println(\"${1:message}\");$0"
    ],
    "description": "Print with newline"
  },
  "Documentation Comment": {
    "prefix": "doc",
    "body": [
      "/**",
      " * ${1:Description}",
      " *",
      " * @param ${2:name} ${3:description}",
      " * @return ${4:description}",
      " */$0"
    ],
    "description": "Documentation comment"
  },
  "Todo Comment": {
    "prefix": "todo",
    "body": [
      "// TODO: ${1:description}$0"
    ],
    "description": "TODO comment"
  },
  "Fixme Comment": {
    "prefix": "fixme",
    "body": [
      "// FIXME: ${1:description}$0"
    ],
    "description": "FIXME comment"
  },
  "Module Declaration": {
    "prefix": "mod",
    "body": [
      "mod ${1:name} {",
      "\t$0",
      "}"
    ],
    "description": "Module declaration"
  },
  "Use Statement": {
    "prefix": "use",
    "body": [
      "use ${1:module}::${2:item};$0"
    ],
    "description": "Use/import statement"
  },
  "Pub Function": {
    "prefix": "pubfn",
    "body": [
      "pub fn ${1:name}(${2:params}) -> ${3:ReturnType} {",
      "\t$0",
      "}"
    ],
    "description": "Public function"
  },
  "Defer Statement": {
    "prefix": "defer",
    "body": [
      "defer ${1:cleanup};$0"
    ],
    "description": "Defer statement for cleanup"
  },
  "Error Handling": {
    "prefix": "err",
    "body": [
      "if let Err(${1:e}) = ${2:result} {",
      "\t$0",
      "}"
    ],
    "description": "Error handling pattern"
  },
  "Result Unwrap": {
    "prefix": "unwrap",
    "body": [
      "match ${1:result} {",
      "\tOk(${2:val}) => ${2:val},",
      "\tErr(${3:e}) => ${4:panic}(\"Error: {}\", ${3:e}),$0",
      "}"
    ],
    "description": "Result unwrap pattern"
  }
}
